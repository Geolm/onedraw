#ifndef __rasterization_shader__H__
#define __rasterization_shader__H__

#include <stddef.h>

static const size_t rasterization_shader_size = 21812;
static const char rasterization_shader[] =
    "#include <metal_stdlib>\n"
    "#define RASTERIZER_SHADER\n"
    "#ifndef __COMMON_H__\n"
    "#define __COMMON_H__\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// This file is included by the cpp renderer and the shaders\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// renderer constants\n"
    "#define TILE_SIZE (16)\n"
    "#define REGION_SIZE (16)\n"
    "#define MAX_NODES_COUNT (1<<22)\n"
    "#define INVALID_INDEX (0xffffffff)\n"
    "#define MAX_CLIPS (256)\n"
    "#define MAX_COMMANDS (1<<16)\n"
    "#define MAX_DRAWDATA (MAX_COMMANDS * 4)\n"
    "#define SIMD_GROUP_SIZE (32)\n"
    "#define LAST_COMMAND (MAX_COMMANDS-1)\n"
    "#define MAX_THREADS_PER_THREADGROUP (1024)\n"
    "#define MAX_GLYPHS (128)\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// cpp compatibility\n"
    "#ifndef __METAL_VERSION__\n"
    "#pragma once\n"
    "#define constant\n"
    "#define atomic_uint uint32_t\n"
    "#define device\n"
    "#define command_buffer void*\n"
    "#define texture_half uint64_t\n"
    "#ifdef __cplusplus\n"
    "    typedef struct alignas(8) {float x, y;} float2;\n"
    "    typedef struct alignas(16) {float x, y, z, w;} float4;\n"
    "#else\n"
    "    typedef struct {float x, y;} float2;\n"
    "    typedef struct {float x, y, z, w;} float4;\n"
    "#endif\n"
    "#else\n"
    "using namespace metal;\n"
    "#define texture_half texture2d<half>\n"
    "#endif\n"
    "\n"
    "// packed on 6 bits\n"
    "enum command_type\n"
    "{\n"
    "    primitive_char = 0,\n"
    "    primitive_aabox = 1,\n"
    "    primitive_oriented_box = 2,\n"
    "    primitive_disc = 3,\n"
    "    primitive_triangle = 4,\n"
    "    primitive_ellipse = 5,\n"
    "    primitive_pie = 6,\n"
    "    primitive_arc = 7,\n"
    "    primitive_blurred_box = 8,\n"
    "    primitive_quad = 9,\n"
    "    \n"
    "    begin_group = 32,\n"
    "    end_group = 33\n"
    "};\n"
    "\n"
    "enum primitive_fillmode\n"
    "{\n"
    "    fill_solid = 0,\n"
    "    fill_outline = 1,\n"
    "    fill_hollow = 2,\n"
    "    fill_last = 3\n"
    "};\n"
    "\n"
    "#define COMMAND_TYPE_MASK   (0x3f)\n"
    "#define PRIMITIVE_FILLMODE_MASK (0xC0)\n"
    "#define PRIMITIVE_FILLMODE_SHIFT (6)\n"
    "\n"
    "\n"
    "enum sdf_operator\n"
    "{\n"
    "    op_overwrite = 0,\n"
    "    op_blend = 1\n"
    "};\n"
    "\n"
    "// packed 8 bytes structure\n"
    "typedef struct draw_command\n"
    "{\n"
    "    uint32_t data_index;\n"
    "#ifdef RASTERIZER_SHADER\n"
    "    uint32_t packed_data;\n"
    "#else\n"
    "    uint8_t extra;\n"
    "    uint8_t clip_index;\n"
    "    uint8_t fillmode;\n"
    "    uint8_t type;\n"
    "#endif\n"
    "} draw_command;\n"
    "\n"
    "typedef struct tile_node\n"
    "{\n"
    "    uint32_t next;\n"
    "    uint16_t command_index;\n"
    "    uint8_t command_type;\n"
    "    uint8_t padding;\n"
    "} tile_node;\n"
    "\n"
    "typedef struct counters\n"
    "{\n"
    "    atomic_uint num_nodes;\n"
    "    atomic_uint num_tiles;\n"
    "    uint32_t pad[2];\n"
    "} counters;\n"
    "\n"
    "typedef struct clip_rect\n"
    "{\n"
    "    float min_x, min_y, max_x, max_y;\n"
    "} clip_rect;\n"
    "\n"
    "typedef struct quantized_aabb\n"
    "{\n"
    "#ifdef RASTERIZER_SHADER\n"
    "    uint32_t packed_data;\n"
    "#else\n"
    "    uint8_t min_x;\n"
    "    uint8_t min_y;\n"
    "    uint8_t max_x;\n"
    "    uint8_t max_y;\n"
    "#endif\n"
    "} quantized_aabb;\n"
    "\n"
    "typedef struct font_char\n"
    "{\n"
    "    float2 uv_topleft;\n"
    "    float2 uv_bottomright;\n"
    "    float width;\n"
    "    float height;\n"
    "} font_char;\n"
    "\n"
    "typedef struct draw_cmd_arguments\n"
    "{\n"
    "    constant draw_command* commands;\n"
    "    constant uint32_t* colors;\n"
    "    constant quantized_aabb* commands_aabb;\n"
    "    constant float* draw_data;\n"
    "    constant clip_rect* clips;\n"
    "    constant font_char* glyphs;\n"
    "    texture_half font;\n"
    "    float4 clear_color;\n"
    "    uint32_t num_commands;\n"
    "    uint32_t max_nodes;\n"
    "    uint32_t num_tile_width;\n"
    "    uint32_t num_tile_height;\n"
    "    uint32_t num_region_width;\n"
    "    uint32_t num_region_height;\n"
    "    uint32_t num_groups;\n"
    "    float aa_width;\n"
    "    float2 screen_div;\n"
    "    uint32_t num_elements_per_thread;\n"
    "    bool culling_debug;\n"
    "    bool srgb_backbuffer;\n"
    "} draw_cmd_arguments;\n"
    "\n"
    "typedef struct tiles_data\n"
    "{\n"
    "    device uint32_t* head;\n"
    "    device tile_node* nodes;\n"
    "    device uint16_t* tile_indices;\n"
    "} tiles_data;\n"
    "\n"
    "typedef struct output_command_buffer\n"
    "{\n"
    "    command_buffer cmd_buffer;\n"
    "} output_command_buffer;\n"
    "\n"
    "#ifdef __METAL_VERSION__\n"
    "inline float2 skew(float2 v) {return float2(-v.y, v.x);}\n"
    "inline float cross2(float2 a, float2 b ) {return a.x*b.y - a.y*b.x;}\n"
    "\n"
    "template<typename T>\n"
    "T linearstep(T edge0, T edge1, T x)\n"
    "{\n"
    "    return clamp((x - edge0) / (edge1 - edge0), T(0), T(1));\n"
    "}\n"
    "#endif\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// cpp compatibility\n"
    "#ifndef __METAL_VERSION__\n"
    "#undef constant\n"
    "#undef atomic_uint\n"
    "#undef device\n"
    "#undef command_buffer\n"
    "#endif\n"
    "\n"
    "\n"
    "#endif\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// signed distance functions\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "\n"
    "static inline float erf(float x) {return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));}\n"
    "static inline float sd_disc(float2 position, float2 center, float radius) {return length(center-position) - radius;}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "// based on https://www.shadertoy.com/view/NsVSWy\n"
    "//   [blur_radius] is half of the roundness\n"
    "// returns a float2\n"
    "//      .x = distance to box\n"
    "//      .y = gaussian blur value (alpha)\n"
    "static inline float2 sd_gaussian_box(float2 position, float2 box_center, float2 box_size, float radius)\n"
    "{\n"
    "    position -= box_center;\n"
    "    float2 d = abs(position) - box_size;\n"
    "    float sd = length(max(d,0.0)) + min(max(d.x,d.y),0.0) - radius;\n"
    "    float blur_radius = radius * 0.5f;\n"
    "\n"
    "    float u = erf((position.x + box_size.x) / blur_radius) - erf((position.x - box_size.x) / blur_radius);\n"
    "    float v = erf((position.y + box_size.y) / blur_radius) - erf((position.y - box_size.y) / blur_radius);\n"
    "    return float2(sd, u * v / 4.0);\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "static inline float sd_aabox(float2 position, float2 box_center, float2 half_extents, float radius)\n"
    "{\n"
    "    position -= box_center;\n"
    "    position = abs(position) - half_extents + radius;\n"
    "    return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - radius;\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "static inline float sd_oriented_box(float2 position, float2 a, float2 b, float width)\n"
    "{\n"
    "    float l = length(b-a);\n"
    "    float2  d = (b-a)/l;\n"
    "    float2  q = (position-(a+b)*0.5);\n"
    "    q = float2x2(d.x,-d.y,d.y,d.x)*q;\n"
    "    q = abs(q)-float2(l,width)*0.5;\n"
    "    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "static inline float sd_triangle(float2 p, float2 p0, float2 p1, float2 p2 )\n"
    "{\n"
    "    float2 e0 = p1 - p0;\n"
    "    float2 e1 = p2 - p1;\n"
    "    float2 e2 = p0 - p2;\n"
    "\n"
    "    float2 v0 = p - p0;\n"
    "    float2 v1 = p - p1;\n"
    "    float2 v2 = p - p2;\n"
    "\n"
    "    float2 pq0 = v0 - e0*saturate(dot(v0,e0)/dot(e0,e0));\n"
    "    float2 pq1 = v1 - e1*saturate(dot(v1,e1)/dot(e1,e1));\n"
    "    float2 pq2 = v2 - e2*saturate(dot(v2,e2)/dot(e2,e2));\n"
    "    \n"
    "    float s = e0.x*e2.y - e0.y*e2.x;\n"
    "    float2 d = min(min(float2(dot(pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x)),\n"
    "                       float2(dot(pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x))),\n"
    "                       float2(dot(pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x)));\n"
    "\n"
    "    return -sqrt(d.x)*sign(d.y);\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "// based on https://www.shadertoy.com/view/tt3yz7\n"
    "static inline float sd_ellipse(float2 p, float2 e)\n"
    "{\n"
    "    float2 pAbs = abs(p);\n"
    "    float2 ei = 1.f / e;\n"
    "    float2 e2 = e*e;\n"
    "    float2 ve = ei * float2(e2.x - e2.y, e2.y - e2.x);\n"
    "    \n"
    "    float2 t = float2(0.70710678118654752f, 0.70710678118654752f);\n"
    "\n"
    "    // hopefully unroll by the compiler\n"
    "    for (int i = 0; i < 3; i++) \n"
    "    {\n"
    "        float2 v = ve*t*t*t;\n"
    "        float2 u = normalize(pAbs - v) * length(t * e - v);\n"
    "        float2 w = ei * (v + u);\n"
    "        t = normalize(saturate(w));\n"
    "    }\n"
    "    \n"
    "    float2 nearestAbs = t * e;\n"
    "    float dist = length(pAbs - nearestAbs);\n"
    "    return dot(pAbs, pAbs) < dot(nearestAbs, nearestAbs) ? -dist : dist;\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "static inline float sd_oriented_ellipse(float2 position, float2 a, float2 b, float width)\n"
    "{\n"
    "    float height = length(b-a);\n"
    "    float2  axis = (b-a)/height;\n"
    "    float2  position_translated = (position-(a+b)*.5f);\n"
    "    float2 position_boxspace = float2x2(axis.x,-axis.y, axis.y, axis.x)*position_translated;\n"
    "    return sd_ellipse(position_boxspace, float2(height * .5f, width * .5f));\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "static inline float sd_oriented_pie(float2 position, float2 center, float2 direction, float2 aperture, float radius)\n"
    "{\n"
    "    direction = -skew(direction);\n"
    "    position -= center;\n"
    "    position = float2x2(direction.x,-direction.y, direction.y, direction.x) * position;\n"
    "    position.x = abs(position.x);\n"
    "    float l = length(position) - radius;\n"
    "\tfloat m = length(position - aperture*clamp(dot(position,aperture),0.f,radius));\n"
    "    return max(l,m*sign(aperture.y*position.x - aperture.x*position.y));\n"
    "}\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "static inline float sd_oriented_ring(float2 position, float2 center, float2 direction, float2 aperture, float radius, float thickness)\n"
    "{\n"
    "    direction = -skew(direction);\n"
    "    position -= center;\n"
    "    position = float2x2(direction.x,-direction.y, direction.y, direction.x) * position;\n"
    "    position.x = abs(position.x);\n"
    "    position = float2x2(aperture.y,aperture.x,-aperture.x,aperture.y)*position;\n"
    "    return max(abs(length(position)-radius)-thickness*0.5,length(float2(position.x,max(0.0,abs(radius-position.y)-thickness*0.5)))*sign(position.x) );\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// smooth minimum : quadratic polynomial\n"
    "//\n"
    "// note : a primitive is on top of b primitive. Also it handle a anti-aliased primitive going over another primitive and keeping \n"
    "//        the right width of anti-aliasing \n"
    "//\n"
    "// returns\n"
    "//  .x = smallest distance\n"
    "//  .y = blend factor between [0; 1]\n"
    "float2 smooth_minimum(float a, float b, float k)\n"
    "{\n"
    "    b = max(b, 0.f);    // a is always on top\n"
    "    if (k>0.f)\n"
    "    {\n"
    "        float h = max( k-abs(a-b), 0.0f )/k;\n"
    "        float m = h*h*h*0.5;\n"
    "        float s = m*k*(1.0f/3.0f); \n"
    "        return (a<b) ? float2(a-s, 0.f) : float2(b-s, 1.f - smoothstep(-k, 0.f, b-a));\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // hard min\n"
    "        return float2(min(a, b),  (a<b) ? 0.f : 1.f);\n"
    "    }\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline half4 accumulate_color(half4 color, half4 backbuffer)\n"
    "{\n"
    "    half3 rgb = mix(backbuffer.rgb, color.rgb, color.a);\n"
    "    return half4(rgb, 1.h);\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline half linear_to_srgb_channel(half c) \n"
    "{\n"
    "    if (c <= 0.0031308h)\n"
    "        return c * 12.92h;\n"
    "    else\n"
    "        return 1.055h * pow(c, 1.0h / 2.4h) - 0.055h;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "half4 linear_to_srgb(half4 linear_color) \n"
    "{\n"
    "    return half4(linear_to_srgb_channel(linear_color.r),linear_to_srgb_channel(linear_color.g),\n"
    "                 linear_to_srgb_channel(linear_color.b),linear_color.a);\n"
    "}\n"
    "\n"
    "struct vs_out\n"
    "{\n"
    "    float4 pos [[position]];\n"
    "    uint16_t tile_index [[flat]];\n"
    "};\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// vertex shader\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "vertex vs_out tile_vs(uint instance_id [[instance_id]],\n"
    "                      uint vertex_id [[vertex_id]],\n"
    "                      constant draw_cmd_arguments& input [[buffer(0)]],\n"
    "                      constant uint16_t* tile_indices [[buffer(1)]])\n"
    "{\n"
    "    vs_out out;\n"
    "\n"
    "    uint16_t tile_index = tile_indices[instance_id];\n"
    "    uint16_t tile_x = tile_index % input.num_tile_width;\n"
    "    uint16_t tile_y = tile_index / input.num_tile_width;\n"
    "    \n"
    "    float2 screen_pos = float2(vertex_id&1, vertex_id>>1);\n"
    "    screen_pos += float2(tile_x, tile_y);\n"
    "    screen_pos *= TILE_SIZE;\n"
    "\n"
    "    float2 clipspace_pos = screen_pos * input.screen_div;\n"
    "    clipspace_pos = (clipspace_pos * 2.f) - 1.f;\n"
    "    clipspace_pos.y = -clipspace_pos.y;\n"
    "\n"
    "    out.pos = float4(clipspace_pos.xy, 0.f, 1.0f);\n"
    "    out.tile_index = tile_index;\n"
    "\n"
    "    return out;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// fragment shader\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "fragment half4 tile_fs(vs_out in [[stage_in]],\n"
    "                       constant draw_cmd_arguments& input [[buffer(0)]],\n"
    "                       device tiles_data& tiles [[buffer(1)]])\n"
    "{\n"
    "    half4 output = input.culling_debug ? half4(0.f, 0.f, 1.0f, 1.0f) : half4(input.clear_color);\n"
    "    uint32_t node_index = tiles.head[in.tile_index];\n"
    "    if (node_index == INVALID_INDEX)\n"
    "        return output;\n"
    "\n"
    "    float previous_distance;\n"
    "    half4 previous_color;\n"
    "    float group_smoothness;\n"
    "    sdf_operator group_op = op_overwrite;\n"
    "    bool grouping = false;\n"
    "\n"
    "    float outline_width = 0.f;\n"
    "    float outline_start = -input.aa_width;\n"
    "\n"
    "    while (node_index != INVALID_INDEX)\n"
    "    {\n"
    "        const tile_node node = tiles.nodes[node_index];\n"
    "        constant draw_command* raw_cmd = &input.commands[node.command_index];\n"
    "\n"
    "        uint32_t packed_data = quad_broadcast(raw_cmd->packed_data, 0);\n"
    "        uint8_t extra = packed_data & 0xFF;\n"
    "\n"
    "        constant clip_rect& clip = input.clips[(packed_data >> 8) & 0xFF];\n"
    "        const uint32_t data_index = quad_broadcast(raw_cmd->data_index, 0);\n"
    "        const command_type type = (command_type) ((packed_data >> 24) & 0xFF);\n"
    "        const primitive_fillmode fillmode = (primitive_fillmode) ((packed_data >> 16) & 0xFF);\n"
    "        half4 cmd_color = unpack_unorm4x8_srgb_to_half(input.colors[node.command_index]);\n"
    "\n"
    "        // check if the pixel is in the clip rect\n"
    "        if (all(float4(in.pos.xy, clip.max_x, clip.max_y) >= float4(clip.min_x, clip.min_y, in.pos.xy)))\n"
    "        {\n"
    "            float distance = 10.f;\n"
    "            constant float* data = &input.draw_data[data_index];\n"
    "\n"
    "            if (type == begin_group)\n"
    "            {\n"
    "                previous_color = 0.h;\n"
    "                previous_distance = 100000000.f;\n"
    "                group_smoothness = data[0];\n"
    "                grouping = true;\n"
    "                group_op = (sdf_operator) extra;\n"
    "                outline_width = data[1];\n"
    "                outline_start = -outline_width - input.aa_width;\n"
    "            }\n"
    "            else\n"
    "            {\n"
    "                switch(type)\n"
    "                {\n"
    "                case primitive_disc :\n"
    "                {\n"
    "                    float2 center = float2(data[0], data[1]);\n"
    "                    float radius = data[2];\n"
    "                    distance = sd_disc(in.pos.xy, center, radius);\n"
    "                    if (fillmode == fill_hollow)\n"
    "                        distance = abs(distance) - data[3];\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_oriented_box :\n"
    "                {\n"
    "                    float2 p0 = float2(data[0], data[1]);\n"
    "                    float2 p1 = float2(data[2], data[3]);\n"
    "                    distance = sd_oriented_box(in.pos.xy, p0, p1, data[4]);\n"
    "                    if (fillmode == fill_hollow)\n"
    "                        distance = abs(distance);\n"
    "                    distance -= data[5];\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_ellipse :\n"
    "                {\n"
    "                    float2 p0 = float2(data[0], data[1]);\n"
    "                    float2 p1 = float2(data[2], data[3]);\n"
    "                    distance = sd_oriented_ellipse(in.pos.xy, p0, p1, data[4]);\n"
    "                    if (fillmode == fill_hollow)\n"
    "                        distance = abs(distance) - data[5];\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_aabox:\n"
    "                {\n"
    "                    float2 center = float2(data[0], data[1]);\n"
    "                    float2 half_extents = float2(data[2], data[3]);\n"
    "                    float radius = data[4];\n"
    "                    distance = sd_aabox(in.pos.xy, center, half_extents, radius);\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_char:\n"
    "                {\n"
    "                    uint glyph_index = extra;\n"
    "                    if (glyph_index<MAX_GLYPHS)\n"
    "                    {\n"
    "                        float2 top_left = float2(data[0], data[1]);\n"
    "                        constant font_char& g = input.glyphs[glyph_index];\n"
    "                        float2 uv_topleft = g.uv_topleft;\n"
    "                        float2 uv_bottomright = g.uv_bottomright;\n"
    "                        float2 char_size = float2(g.width, g.height);\n"
    "                        float2 t = (in.pos.xy - top_left) / char_size.xy;\n"
    "\n"
    "                        if (all(t >= 0.f && t <= 1.f))\n"
    "                        {\n"
    "                            float2 uv = mix(uv_topleft, uv_bottomright, t);\n"
    "                            constexpr sampler s(address::clamp_to_zero, filter::linear );\n"
    "                            half texel = 1.h - input.font.sample(s, uv).r;\n"
    "                            distance = texel * input.aa_width;\n"
    "                        }\n"
    "                    }\n"
    "\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_triangle:\n"
    "                {\n"
    "                    float2 p0 = float2(data[0], data[1]);\n"
    "                    float2 p1 = float2(data[2], data[3]);\n"
    "                    float2 p2 = float2(data[4], data[5]);\n"
    "                    distance = sd_triangle(in.pos.xy, p0, p1, p2);\n"
    "                    \n"
    "                    if (fillmode == fill_hollow)\n"
    "                        distance = abs(distance);\n"
    "                        \n"
    "                    distance -= data[6];\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_pie:\n"
    "                {\n"
    "                    float2 center = float2(data[0], data[1]);\n"
    "                    float radius = data[2];\n"
    "                    float2 direction = float2(data[3], data[4]);\n"
    "                    float2 aperture = float2(data[5], data[6]);\n"
    "\n"
    "                    distance = sd_oriented_pie(in.pos.xy, center, direction, aperture, radius);\n"
    "                    if (fillmode == fill_hollow)\n"
    "                        distance = abs(distance) - data[7];\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_arc:\n"
    "                {\n"
    "                    float2 center = float2(data[0], data[1]);\n"
    "                    float radius = data[2];\n"
    "                    float2 direction = float2(data[3], data[4]);\n"
    "                    float2 aperture = float2(data[5], data[6]);\n"
    "                    float thickness = data[7];\n"
    "\n"
    "                    distance = sd_oriented_ring(in.pos.xy, center, direction, aperture, radius, thickness);\n"
    "                    if (fillmode == fill_hollow)\n"
    "                        distance = abs(distance) - data[7];\n"
    "                    break;\n"
    "                }\n"
    "                case primitive_blurred_box:\n"
    "                {\n"
    "                    float2 center = float2(data[0], data[1]);\n"
    "                    float2 size = float2(data[2], data[3]);\n"
    "                    float roundness = data[4];\n"
    "\n"
    "                    float2 dist_alpha = sd_gaussian_box(in.pos.xy, center, size, roundness);\n"
    "\n"
    "                    distance = dist_alpha.x;\n"
    "                    cmd_color.a *= dist_alpha.y;\n"
    "                    break;\n"
    "                }\n"
    "                default: break;\n"
    "                }\n"
    "\n"
    "                half4 color;\n"
    "                if (type == end_group)\n"
    "                {\n"
    "                    grouping = false;\n"
    "                    color = previous_color;\n"
    "                    distance = previous_distance;\n"
    "                    group_op = op_overwrite;\n"
    "                }\n"
    "                else\n"
    "                {\n"
    "                    color = cmd_color;\n"
    "                }\n"
    "\n"
    "                // blend distance / color and skip writing output\n"
    "                if (grouping)\n"
    "                {\n"
    "                    float smooth_factor = (group_op == op_blend) ? group_smoothness : input.aa_width;\n"
    "                    float2 smooth = smooth_minimum(distance, previous_distance, smooth_factor);\n"
    "                    previous_distance = smooth.x;\n"
    "                    previous_color = mix(color, previous_color, smooth.y);\n"
    "                }\n"
    "                else\n"
    "                {\n"
    "                    half alpha_factor;\n"
    "                    if (outline_width > 0.f && type == end_group)\n"
    "                    {\n"
    "                        if (distance > input.aa_width)\n"
    "                            color.rgb = cmd_color.rgb;\n"
    "                        else\n"
    "                            color.rgb = mix(cmd_color.rgb, color.rgb, linearstep(input.aa_width, 0.f, distance));\n"
    "                        alpha_factor = linearstep(half(input.aa_width*2+outline_width), half(input.aa_width+outline_width), half(distance));    // anti-aliasing\n"
    "\n"
    "                        outline_width = 0.f;\n"
    "                        outline_start = -input.aa_width;\n"
    "                    }\n"
    "                    else\n"
    "                        alpha_factor = linearstep(half(input.aa_width), 0.h, half(distance));    // anti-aliasing\n"
    "\n"
    "                    color.a *= alpha_factor;\n"
    "                    output = accumulate_color(color, output);\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "        node_index = node.next;\n"
    "    }\n"
    "\n"
    "    if (!input.srgb_backbuffer)\n"
    "        output = linear_to_srgb(output);\n"
    "\n"
    "    return output;\n"
    "}\n"
;

#endif // __rasterization_shader__H__
