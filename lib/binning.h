#ifndef __binning_shader__H__
#define __binning_shader__H__

#include <stddef.h>

const size_t binning_shader_size = 31144;
const char* binning_shader =

    "#include <metal_stdlib>\n"
    "#ifndef __COMMON_H__\n"
    "#define __COMMON_H__\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// This file is included by the cpp renderer and the shaders\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// renderer constants\n"
    "#define TILE_SIZE (16)\n"
    "#define REGION_SIZE (16)\n"
    "#define MAX_NODES_COUNT (1<<22)\n"
    "#define INVALID_INDEX (0xffffffff)\n"
    "#define MAX_CLIPS (256)\n"
    "#define MAX_COMMANDS (1<<16)\n"
    "#define MAX_DRAWDATA (MAX_COMMANDS * 4)\n"
    "#define SIMD_GROUP_SIZE (32)\n"
    "#define LAST_COMMAND (MAX_COMMANDS-1)\n"
    "#define MAX_THREADS_PER_THREADGROUP (1024)\n"
    "#define MAX_GLYPHS (128)\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// cpp compatibility\n"
    "#ifndef __METAL_VERSION__\n"
    "#pragma once\n"
    "#define constant\n"
    "#define atomic_uint uint32_t\n"
    "#define device\n"
    "#define command_buffer void*\n"
    "#define texture_half uint64_t\n"
    "#ifdef __cplusplus\n"
    "    typedef struct alignas(8) {float x, y;} float2;\n"
    "    typedef struct alignas(16) {float x, y, z, w;} float4;\n"
    "#else\n"
    "    typedef struct {float x, y;} float2;\n"
    "    typedef struct {float x, y, z, w;} float4;\n"
    "#endif\n"
    "#else\n"
    "using namespace metal;\n"
    "#define texture_half texture2d<half>\n"
    "#endif\n"
    "\n"
    "// packed on 6 bits\n"
    "enum command_type\n"
    "{\n"
    "    primitive_char = 0,\n"
    "    primitive_aabox = 1,\n"
    "    primitive_oriented_box = 2,\n"
    "    primitive_disc = 3,\n"
    "    primitive_triangle = 4,\n"
    "    primitive_ellipse = 5,\n"
    "    primitive_pie = 6,\n"
    "    primitive_arc = 7,\n"
    "    primitive_blurred_box = 8,\n"
    "    \n"
    "    begin_group = 32,\n"
    "    end_group = 33\n"
    "};\n"
    "\n"
    "enum primitive_fillmode\n"
    "{\n"
    "    fill_solid = 0,\n"
    "    fill_outline = 1,\n"
    "    fill_hollow = 2,\n"
    "    fill_last = 3\n"
    "};\n"
    "\n"
    "#define COMMAND_TYPE_MASK   (0x3f)\n"
    "#define PRIMITIVE_FILLMODE_MASK (0xC0)\n"
    "#define PRIMITIVE_FILLMODE_SHIFT (6)\n"
    "\n"
    "\n"
    "enum sdf_operator\n"
    "{\n"
    "    op_overwrite = 0,\n"
    "    op_blend = 1\n"
    "};\n"
    "\n"
    "// packed 8 bytes structure\n"
    "typedef struct draw_command\n"
    "{\n"
    "    uint32_t data_index;\n"
    "#ifdef RASTERIZER_SHADER\n"
    "    uint32_t packed_data;\n"
    "#else\n"
    "    uint8_t extra;\n"
    "    uint8_t clip_index;\n"
    "    uint8_t fillmode;\n"
    "    uint8_t type;\n"
    "#endif\n"
    "} draw_command;\n"
    "\n"
    "typedef struct tile_node\n"
    "{\n"
    "    uint32_t next;\n"
    "    uint16_t command_index;\n"
    "    uint8_t command_type;\n"
    "    uint8_t padding;\n"
    "} tile_node;\n"
    "\n"
    "typedef struct counters\n"
    "{\n"
    "    atomic_uint num_nodes;\n"
    "    atomic_uint num_tiles;\n"
    "    uint32_t pad[2];\n"
    "} counters;\n"
    "\n"
    "typedef struct clip_rect\n"
    "{\n"
    "    float min_x, min_y, max_x, max_y;\n"
    "} clip_rect;\n"
    "\n"
    "typedef struct quantized_aabb\n"
    "{\n"
    "#ifdef RASTERIZER_SHADER\n"
    "    uint32_t packed_data;\n"
    "#else\n"
    "    uint8_t min_x;\n"
    "    uint8_t min_y;\n"
    "    uint8_t max_x;\n"
    "    uint8_t max_y;\n"
    "#endif\n"
    "} quantized_aabb;\n"
    "\n"
    "typedef struct font_char\n"
    "{\n"
    "    float2 uv_topleft;\n"
    "    float2 uv_bottomright;\n"
    "    float width;\n"
    "    float height;\n"
    "} font_char;\n"
    "\n"
    "typedef struct draw_cmd_arguments\n"
    "{\n"
    "    constant draw_command* commands;\n"
    "    constant uint32_t* colors;\n"
    "    constant quantized_aabb* commands_aabb;\n"
    "    constant float* draw_data;\n"
    "    constant clip_rect* clips;\n"
    "    constant font_char* glyphs;\n"
    "    texture_half font;\n"
    "    float4 clear_color;\n"
    "    uint32_t num_commands;\n"
    "    uint32_t max_nodes;\n"
    "    uint32_t num_tile_width;\n"
    "    uint32_t num_tile_height;\n"
    "    uint32_t num_region_width;\n"
    "    uint32_t num_region_height;\n"
    "    uint32_t num_groups;\n"
    "    float aa_width;\n"
    "    float2 screen_div;\n"
    "    uint32_t num_elements_per_thread;\n"
    "    bool culling_debug;\n"
    "} draw_cmd_arguments;\n"
    "\n"
    "typedef struct tiles_data\n"
    "{\n"
    "    device uint32_t* head;\n"
    "    device tile_node* nodes;\n"
    "    device uint16_t* tile_indices;\n"
    "} tiles_data;\n"
    "\n"
    "typedef struct output_command_buffer\n"
    "{\n"
    "    command_buffer cmd_buffer;\n"
    "} output_command_buffer;\n"
    "\n"
    "#ifdef __METAL_VERSION__\n"
    "inline float2 skew(float2 v) {return float2(-v.y, v.x);}\n"
    "inline float cross2(float2 a, float2 b ) {return a.x*b.y - a.y*b.x;}\n"
    "\n"
    "template<typename T>\n"
    "T linearstep(T edge0, T edge1, T x)\n"
    "{\n"
    "    return clamp((x - edge0) / (edge1 - edge0), T(0), T(1));\n"
    "}\n"
    "#endif\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// cpp compatibility\n"
    "#ifndef __METAL_VERSION__\n"
    "#undef constant\n"
    "#undef atomic_uint\n"
    "#undef device\n"
    "#undef command_buffer\n"
    "#endif\n"
    "\n"
    "\n"
    "#endif\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// Collisions functions\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "\n"
    "struct aabb\n"
    "{\n"
    "    float2 min;\n"
    "    float2 max;\n"
    "};\n"
    "\n"
    "static inline aabb aabb_grow(aabb box, float2 amount)\n"
    "{\n"
    "    return (aabb) {.min = box.min - amount, .max = box.max + amount};\n"
    "}\n"
    "\n"
    "static inline float2 aabb_get_extents(aabb box) {return box.max - box.min;}\n"
    "\n"
    "template <class T> T square(T value) {return value*value;}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline float edge_distance(float2 p, float2 e0, float2 e1)\n"
    "{\n"
    "    return (p.x - e1.x) * (e0.y - e1.y) - (e0.x - e1.x) * (p.y - e1.y);\n"
    "}\n"
    "\n"
    "struct obb\n"
    "{\n"
    "    float2 axis_i;\n"
    "    float2 axis_j;\n"
    "    float2 center;\n"
    "    float2 extents;\n"
    "};\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "obb compute_obb(float2 p0, float2 p1, float width)\n"
    "{\n"
    "    obb result;\n"
    "    result.center = (p0 + p1) * .5f;\n"
    "    result.axis_j = (p1 - result.center);\n"
    "    result.extents.y = length(result.axis_j);\n"
    "    result.axis_j /= result.extents.y;\n"
    "    result.axis_i = skew(result.axis_j);\n"
    "    result.extents.x = width * .5f;\n"
    "    return result;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline float2 obb_transform(obb obox, float2 point)\n"
    "{\n"
    "    point = point - obox.center;\n"
    "    return float2(abs(dot(obox.axis_i, point)), abs(dot(obox.axis_j, point)));\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// slab test\n"
    "bool intersection_aabb_ray(aabb box, float2 origin, float2 direction)\n"
    "{\n"
    "    float tmin = 0.f;\n"
    "    float tmax = 1e10f;\n"
    "    for (int i = 0; i < 2; i++)\n"
    "    {\n"
    "        float inv_dir = 1.f / direction[i];\n"
    "        float t1 = (box.min[i] - origin[i]) * inv_dir;\n"
    "        float t2 = (box.max[i] - origin[i]) * inv_dir;\n"
    "\n"
    "        if (t1 > t2)\n"
    "        {\n"
    "            float temp = t1;\n"
    "            t1 = t2;\n"
    "            t2 = temp;\n"
    "        }\n"
    "\n"
    "        tmin = max(tmin, t1);\n"
    "        tmax = min(tmax, t2);\n"
    "\n"
    "        if (tmin > tmax)\n"
    "            return false;\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline bool intersection_aabb_disc(aabb box, float2 center, float radius)\n"
    "{\n"
    "    float2 nearest_point = clamp(center.xy, box.min, box.max);\n"
    "    return distance_squared(nearest_point, center) < square(radius);\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline bool intersection_aabb_circle(aabb box, float2 center, float radius, float half_width)\n"
    "{\n"
    "    if (!intersection_aabb_disc(box, center, radius + half_width))\n"
    "        return false;\n"
    "\n"
    "    float2 candidate0 = abs(center.xy - box.min);\n"
    "    float2 candidate1 = abs(center.xy - box.max);\n"
    "    float2 furthest_point = max(candidate0, candidate1);\n"
    "\n"
    "    return length_squared(furthest_point) > square(radius - half_width);\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool intersection_aabb_obb(aabb box, float2 p0, float2 p1, float width)\n"
    "{\n"
    "    float2 dir = p1 - p0;\n"
    "    float2 center = (p0 + p1) * 0.5f;\n"
    "    float height = length(dir);\n"
    "\n"
    "    float2 axis_j = dir / height;\n"
    "    float2 axis_i = float2(-axis_j.y, axis_j.x);\n"
    "\n"
    "    float half_i = width * 0.5f;\n"
    "    float half_j = height * 0.5f;\n"
    "\n"
    "    float2 aabb_extent = abs(axis_i * half_i) + abs(axis_j * half_j);\n"
    "    float2 obb_min = center - aabb_extent;\n"
    "    float2 obb_max = center + aabb_extent;\n"
    "    if (any(obb_max < box.min) || any(box.max < obb_min))\n"
    "        return false;\n"
    "\n"
    "    float2 aabb_center = (box.min + box.max) * 0.5f;\n"
    "    float2 aabb_half = (box.max - box.min) * 0.5f;\n"
    "\n"
    "    float d = abs(dot(axis_i, center - aabb_center));\n"
    "    float r = aabb_half.x * abs(axis_i.x) + aabb_half.y * abs(axis_i.y);\n"
    "    if (d > (half_i + r))\n"
    "        return false;\n"
    "\n"
    "    d = abs(dot(axis_j, center - aabb_center));\n"
    "    r = aabb_half.x * abs(axis_j.x) + aabb_half.y * abs(axis_j.y);\n"
    "    if (d > (half_j + r))\n"
    "        return false;\n"
    "\n"
    "    return true;\n"
    "}\n"
    "\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "inline bool intersection_aabb_triangle(aabb box, float2 p0, float2 p1, float2 p2)\n"
    "{\n"
    "    float2 pmin = min(min(p0, p1), p2);\n"
    "    float2 pmax = max(max(p0, p1), p2);\n"
    "    if (any(pmax < box.min) || any(box.max < pmin))\n"
    "        return false;\n"
    "\n"
    "    const float2 v0 = box.min;\n"
    "    const float2 v1 = box.max;\n"
    "    const float2 v2 = float2(box.min.x, box.max.y);\n"
    "    const float2 v3 = float2(box.max.x, box.min.y);\n"
    "\n"
    "    #define EDGE_SEPARATION(e0, e1, refp) do {                         \\\n"
    "        float ref = edge_distance(refp, e0, e1);                       \\\n"
    "        float d0 = edge_distance(v0, e0, e1);                          \\\n"
    "        float d1 = edge_distance(v1, e0, e1);                          \\\n"
    "        float d2 = edge_distance(v2, e0, e1);                          \\\n"
    "        float d3 = edge_distance(v3, e0, e1);                          \\\n"
    "        if (ref > 0.0f) {                                              \\\n"
    "            if (d0 < 0.0f && d1 < 0.0f && d2 < 0.0f && d3 < 0.0f)      \\\n"
    "                return false;                                          \\\n"
    "        } else if (ref < 0.0f) {                                       \\\n"
    "            if (d0 > 0.0f && d1 > 0.0f && d2 > 0.0f && d3 > 0.0f)      \\\n"
    "                return false;                                          \\\n"
    "        }                                                              \\\n"
    "    } while (0)\n"
    "\n"
    "    EDGE_SEPARATION(p0, p1, p2);\n"
    "    EDGE_SEPARATION(p1, p2, p0);\n"
    "    EDGE_SEPARATION(p2, p0, p1);\n"
    "\n"
    "    #undef EDGE_SEPARATION\n"
    "\n"
    "    return true;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool intersection_aabb_pie(aabb box, float2 center, float2 direction, float2 aperture, float radius)\n"
    "{\n"
    "    if (!intersection_aabb_disc(box, center, radius))\n"
    "        return false;\n"
    "\n"
    "    float2 aabb_vertices[4]; \n"
    "    aabb_vertices[0] = box.min;\n"
    "    aabb_vertices[1] = box.max;\n"
    "    aabb_vertices[2] = float2(box.min.x, box.max.y);\n"
    "    aabb_vertices[3] = float2(box.max.x, box.min.y);\n"
    "\n"
    "    for(int i=0; i<4; ++i)\n"
    "    {\n"
    "        float2 center_vertex = normalize(aabb_vertices[i] - center);\n"
    "        if (dot(center_vertex, direction) > aperture.y)\n"
    "            return true;\n"
    "    }\n"
    "    return intersection_aabb_ray(box, center, direction);\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool intersection_aabb_arc(aabb box, float2 center, float2 direction, float2 aperture, float radius, float thickness)\n"
    "{\n"
    "    float half_thickness = thickness * .5f;\n"
    "\n"
    "    if (!intersection_aabb_circle(box, center, radius, half_thickness))\n"
    "        return false;\n"
    "\n"
    "    return intersection_aabb_pie(box, center, direction, aperture, radius + half_thickness);\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool point_in_triangle(float2 p0, float2 p1, float2 p2, float2 point)\n"
    "{\n"
    "    float d1, d2, d3;\n"
    "    bool has_neg, has_pos;\n"
    "\n"
    "    d1 = edge_distance(point, p0, p1);\n"
    "    d2 = edge_distance(point, p1, p2);\n"
    "    d3 = edge_distance(point, p2, p0);\n"
    "\n"
    "    has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n"
    "    has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n"
    "\n"
    "    return !(has_neg && has_pos);\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline bool point_in_pie(float2 center, float2 direction, float radius, float cos_aperture, float2 point)\n"
    "{\n"
    "    if (distance_squared(center, point) > square(radius))\n"
    "        return false;\n"
    "\n"
    "    float2 to_point = normalize(point - center);\n"
    "    return dot(to_point, direction) > cos_aperture;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "static inline bool intersection_ellipse_circle(float2 p0, float2 p1, float width, float2 center, float radius)\n"
    "{\n"
    "    obb obox = compute_obb(p0, p1, width);\n"
    "    center = obb_transform(obox, center);\n"
    "    \n"
    "    float2 transformed_center = center / obox.extents;\n"
    "    float scaled_radius = radius / min(obox.extents.x, obox.extents.y);\n"
    "    float squared_distance = dot(transformed_center, transformed_center);\n"
    "\n"
    "    return (squared_distance <= square(1.f + scaled_radius));\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool is_aabb_inside_ellipse(float2 p0, float2 p1, float width, aabb box)\n"
    "{\n"
    "    float2 aabb_vertices[4]; \n"
    "    aabb_vertices[0] = box.min;\n"
    "    aabb_vertices[1] = box.max;\n"
    "    aabb_vertices[2] = float2(box.min.x, box.max.y);\n"
    "    aabb_vertices[3] = float2(box.max.x, box.min.y);\n"
    "\n"
    "    obb obox = compute_obb(p0, p1, width);\n"
    "\n"
    "    // transform each vertex in ellipse space and test all are in the ellipse\n"
    "    for(int i=0; i<4; ++i)\n"
    "    {\n"
    "        float2 vertex_ellipse_space = obb_transform(obox, aabb_vertices[i]);\n"
    "        float distance =  square(vertex_ellipse_space.x) / square(obox.extents.x) + square(vertex_ellipse_space.y) / square(obox.extents.y);\n"
    "        if (distance>1.f)\n"
    "            return false;\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool is_aabb_inside_triangle(float2 p0, float2 p1, float2 p2, aabb box)\n"
    "{\n"
    "    float2 aabb_vertices[4]; \n"
    "    aabb_vertices[0] = box.min;\n"
    "    aabb_vertices[1] = box.max;\n"
    "    aabb_vertices[2] = float2(box.min.x, box.max.y);\n"
    "    aabb_vertices[3] = float2(box.max.x, box.min.y);\n"
    "\n"
    "    for(int i=0; i<4; ++i)\n"
    "    {\n"
    "        float d0 = edge_distance(p0, p1, aabb_vertices[i]);\n"
    "        float d1 = edge_distance(p1, p2, aabb_vertices[i]);\n"
    "        float d2 = edge_distance(p2, p0, aabb_vertices[i]);\n"
    "\n"
    "        bool has_neg = (d1 < 0) || (d2 < 0) || (d0 < 0);\n"
    "        bool has_pos = (d1 > 0) || (d2 > 0) || (d0 > 0);\n"
    "\n"
    "        if (has_neg&&has_pos)\n"
    "            return false;\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool is_aabb_inside_obb(float2 p0, float2 p1, float width, aabb box)\n"
    "{\n"
    "    float2 aabb_vertices[4]; \n"
    "    aabb_vertices[0] = box.min;\n"
    "    aabb_vertices[1] = box.max;\n"
    "    aabb_vertices[2] = float2(box.min.x, box.max.y);\n"
    "    aabb_vertices[3] = float2(box.max.x, box.min.y);\n"
    "\n"
    "    obb obox = compute_obb(p0, p1, width);\n"
    "\n"
    "    for(int i=0; i<4; ++i)\n"
    "    {\n"
    "        float2 point = obb_transform(obox, aabb_vertices[i]);\n"
    "        if (any(abs(point) > obox.extents))\n"
    "            return false;\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool is_aabb_inside_pie(float2 center, float2 direction, float2 aperture, float radius, aabb box)\n"
    "{\n"
    "    float2 aabb_vertices[4]; \n"
    "    aabb_vertices[0] = box.min;\n"
    "    aabb_vertices[1] = box.max;\n"
    "    aabb_vertices[2] = float2(box.min.x, box.max.y);\n"
    "    aabb_vertices[3] = float2(box.max.x, box.min.y);\n"
    "\n"
    "    for(int i=0; i<4; ++i)\n"
    "    {\n"
    "        if (!point_in_pie(center, direction, radius, aperture.y, aabb_vertices[i]))\n"
    "            return false;\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// returns true if the command intersects with the tile\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "bool intersection_tile_command(aabb tile_aabb, draw_command cmd, sdf_operator op, constant float* data, float aabb_margin)\n"
    "{\n"
    "    // grow the bounding box for anti-aliasing, smooth blend and outline\n"
    "    aabb tile_enlarge_aabb = aabb_grow(tile_aabb, aabb_margin);\n"
    "\n"
    "    const bool is_hollow = (cmd.fillmode == fill_hollow);\n"
    "    bool intersection = false;\n"
    "\n"
    "    switch(cmd.type)\n"
    "    {\n"
    "        case primitive_oriented_box :\n"
    "        {\n"
    "            float2 p0 = float2(data[0], data[1]);\n"
    "            float2 p1 = float2(data[2], data[3]);\n"
    "            float width = data[4];\n"
    "            aabb tile_rounded = aabb_grow(tile_enlarge_aabb, data[5]);\n"
    "            intersection = intersection_aabb_obb(tile_rounded, p0, p1, width);\n"
    "\n"
    "            if (intersection && is_hollow && is_aabb_inside_obb(p0, p1, width, tile_rounded))\n"
    "                intersection = false;\n"
    "            break;\n"
    "        }\n"
    "        case primitive_ellipse :\n"
    "        {\n"
    "            float2 p0 = float2(data[0], data[1]);\n"
    "            float2 p1 = float2(data[2], data[3]);\n"
    "            float width = data[4];\n"
    "            float2 tile_center = (tile_aabb.min + tile_aabb.max) * .5f;\n"
    "\n"
    "            aabb tile_smooth = aabb_grow(tile_enlarge_aabb, (is_hollow ? data[5] : 0.f));\n"
    "            intersection = intersection_ellipse_circle(p0, p1, width, tile_center, length(aabb_get_extents(tile_smooth) * .5f));\n"
    "\n"
    "            if (intersection && is_hollow && is_aabb_inside_ellipse(p0, p1, width, tile_smooth))\n"
    "                intersection = false;\n"
    "            break;\n"
    "        }\n"
    "        case primitive_arc :\n"
    "        {\n"
    "            float2 center = float2(data[0], data[1]);\n"
    "            float radius = data[2];\n"
    "            float2 direction = float2(data[3], data[4]);\n"
    "            float2 aperture = float2(data[5], data[6]);\n"
    "            float thickness = data[7];\n"
    "            intersection = intersection_aabb_arc(tile_enlarge_aabb, center, direction, aperture, radius, thickness);\n"
    "            break;\n"
    "        }\n"
    "        case primitive_pie :\n"
    "        {\n"
    "            float2 center = float2(data[0], data[1]);\n"
    "            float radius = data[2];\n"
    "            float2 direction = float2(data[3], data[4]);\n"
    "            float2 aperture = float2(data[5], data[6]);\n"
    "\n"
    "            aabb tile_smooth = aabb_grow(tile_enlarge_aabb, (is_hollow ? data[7] : 0.f));\n"
    "            intersection = intersection_aabb_pie(tile_smooth, center, direction, aperture, radius);\n"
    "\n"
    "            if (intersection && is_hollow && is_aabb_inside_pie(center, direction, aperture, radius, tile_smooth))\n"
    "                intersection = false;\n"
    "\n"
    "            break;\n"
    "        }\n"
    "\n"
    "        case primitive_disc :\n"
    "        {\n"
    "            float2 center = float2(data[0], data[1]);\n"
    "            float radius = data[2];\n"
    "\n"
    "            if (is_hollow)\n"
    "            {\n"
    "                float half_width = data[3] + aabb_margin;\n"
    "                intersection = intersection_aabb_circle(tile_aabb, center, radius, half_width);\n"
    "            }\n"
    "            else\n"
    "            {\n"
    "                radius += aabb_margin;\n"
    "                intersection = intersection_aabb_disc(tile_aabb, center, radius);\n"
    "            }\n"
    "            break;\n"
    "        }\n"
    "        case primitive_triangle :\n"
    "        {\n"
    "            float2 p0 = float2(data[0], data[1]);\n"
    "            float2 p1 = float2(data[2], data[3]);\n"
    "            float2 p2 = float2(data[4], data[5]);\n"
    "            aabb tile_rounded = aabb_grow(tile_enlarge_aabb, data[6]);\n"
    "            intersection = intersection_aabb_triangle(tile_rounded, p0, p1, p2);\n"
    "\n"
    "            if (intersection && is_hollow && is_aabb_inside_triangle(p0, p1, p2, tile_rounded))\n"
    "                intersection = false;\n"
    "\n"
    "            break;\n"
    "        }\n"
    "\n"
    "        case begin_group:\n"
    "        case end_group:\n"
    "        case primitive_aabox :\n"
    "        case primitive_blurred_box :\n"
    "        case primitive_char : intersection = true; break;\n"
    "        default : intersection = false; break;\n"
    "    }\n"
    "\n"
    "    return intersection;\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// for each draw command, test aabb vs aabb of the region and put 1 if visible (otherwise 0)\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "kernel void predicate(constant draw_cmd_arguments& input [[buffer(0)]],\n"
    "                      device uint8_t* predicate [[buffer(1)]],\n"
    "                      uint index [[thread_position_in_grid]])\n"
    "{\n"
    "    if (index >= input.num_commands)\n"
    "        return;\n"
    "\n"
    "    // reverse order for the tile linked list \n"
    "    uint cmd_index = input.num_commands - index - 1;\n"
    "\n"
    "    quantized_aabb aabb = input.commands_aabb[cmd_index];\n"
    "    aabb.min_x /= REGION_SIZE; aabb.min_y /= REGION_SIZE;\n"
    "    aabb.max_x /= REGION_SIZE; aabb.max_y /= REGION_SIZE;\n"
    "\n"
    "    for(uint y=0; y<input.num_region_height; ++y)\n"
    "    {\n"
    "        for(uint x=0; x<input.num_region_width; ++x)\n"
    "        {\n"
    "            bool visible = (x >= aabb.min_x && x <= aabb.max_x && y >= aabb.min_y && y <= aabb.max_y);\n"
    "            uint region_index = y * input.num_region_width + x;\n"
    "            uint region_offset = region_index * input.num_commands;\n"
    "            predicate[region_offset + index] = visible ? 1 : 0;\n"
    "        }\n"
    "    }\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// one-pass exclusive scan, using simd_prefix, threadgroup memory\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "kernel void exclusive_scan(constant draw_cmd_arguments& input [[buffer(0)]],\n"
    "                           device const uint8_t* predicate [[buffer(1)]],\n"
    "                           device uint16_t* scan [[buffer(2)]],\n"
    "                           threadgroup uint16_t* simd_totals [[threadgroup(0)]],\n"
    "                           threadgroup uint16_t* simd_offsets [[threadgroup(1)]],\n"
    "                           uint tid_in_tg [[thread_index_in_threadgroup]],\n"
    "                           uint2 tg_size [[threads_per_threadgroup]],\n"
    "                           uint simd_group_id [[simdgroup_index_in_threadgroup]],\n"
    "                           uint2 index [[thread_position_in_grid]])\n"
    "{\n"
    "    const uint threads_per_line = tg_size.x;\n"
    "    const uint region_index = index.y;\n"
    "    const uint region_offset = region_index * input.num_commands;\n"
    "    const uint thread_index = tid_in_tg;\n"
    "\n"
    "    // Compute where this thread starts reading/writing\n"
    "    const uint thread_base_idx = thread_index * input.num_elements_per_thread;\n"
    "\n"
    "    // Local prefix sum\n"
    "    uint16_t local_sum = 0;\n"
    "\n"
    "    for (uint i = 0; i < input.num_elements_per_thread; ++i) \n"
    "    {\n"
    "        uint idx = thread_base_idx + i;\n"
    "        if (idx < input.num_commands)\n"
    "        {\n"
    "            scan[region_offset + idx] = local_sum;\n"
    "            local_sum += predicate[region_offset + idx];\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // Compute SIMD-group total and store\n"
    "    uint16_t group_sum = simd_sum(local_sum);\n"
    "    if (simd_is_first()) \n"
    "        simd_totals[simd_group_id] = group_sum;\n"
    "\n"
    "    threadgroup_barrier(mem_flags::mem_threadgroup);\n"
    "\n"
    "    // Prefix sum across SIMD group totals\n"
    "    const uint num_simd_groups = (threads_per_line + SIMD_GROUP_SIZE - 1) / SIMD_GROUP_SIZE;\n"
    "    if (thread_index < num_simd_groups) \n"
    "    {\n"
    "        uint16_t v = simd_totals[thread_index];\n"
    "        simd_offsets[thread_index] = simd_prefix_exclusive_sum(v);\n"
    "    }\n"
    "\n"
    "    threadgroup_barrier(mem_flags::mem_threadgroup);\n"
    "    uint16_t simd_offset = simd_offsets[simd_group_id];\n"
    "\n"
    "    // Final output write\n"
    "    uint16_t thread_offset = simd_offset + simd_prefix_exclusive_sum(local_sum);\n"
    "    for (uint i = 0; i < input.num_elements_per_thread; ++i) \n"
    "    {\n"
    "        uint idx = thread_base_idx + i;\n"
    "        if (idx < input.num_commands) \n"
    "            scan[region_offset + idx] += thread_offset;\n"
    "    }\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// bin commands for region\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "kernel void region_bin(constant draw_cmd_arguments& input [[buffer(0)]],\n"
    "                       device uint16_t* regions_indices [[buffer(1)]],\n"
    "                       device const uint16_t* scan [[buffer(2)]],\n"
    "                       device const uint8_t* predicate [[buffer(3)]],\n"
    "                       uint2 index [[thread_position_in_grid]])\n"
    "{\n"
    "    uint cmd_index = index.x;\n"
    "    uint region_index = index.y;\n"
    "\n"
    "    if (cmd_index >= input.num_commands)\n"
    "        return;\n"
    "\n"
    "    uint region_offset = region_index * input.num_commands;\n"
    "\n"
    "    if (predicate[region_offset + cmd_index] == 1)\n"
    "    {\n"
    "        uint16_t position = scan[region_offset + cmd_index];\n"
    "        if (position < input.num_commands)\n"
    "            regions_indices[region_offset + position] = input.num_commands - cmd_index - 1;\n"
    "    }\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// linked-list cleaning\n"
    "//      * detect combination with no primitive and skip it\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "void clean_list(device tiles_data& tiles, uint16_t tile_index)\n"
    "{\n"
    "    uint32_t node_index = tiles.head[tile_index];\n"
    "    uint32_t previous_index = INVALID_INDEX;\n"
    "    uint32_t before_begin = INVALID_INDEX;\n"
    "    uint32_t num_primitives = 0;\n"
    "\n"
    "    while (node_index != INVALID_INDEX)\n"
    "    {\n"
    "        tile_node node = tiles.nodes[node_index];\n"
    "    \n"
    "        if (node.command_type == begin_group)\n"
    "        {\n"
    "            before_begin = previous_index;\n"
    "            previous_index = node_index;\n"
    "            num_primitives = 0;\n"
    "        }\n"
    "        else if (node.command_type == end_group)\n"
    "        {\n"
    "            // no primitive\n"
    "            if (num_primitives == 0)\n"
    "            {\n"
    "                // change head\n"
    "                if (before_begin == INVALID_INDEX)\n"
    "                    tiles.head[tile_index] = node.next;\n"
    "                else\n"
    "                    tiles.nodes[before_begin].next = node.next;\n"
    "\n"
    "                previous_index = before_begin;\n"
    "            }\n"
    "            else\n"
    "                previous_index = node_index;\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            num_primitives++;\n"
    "            previous_index = node_index;\n"
    "        }\n"
    "\n"
    "        node_index = node.next;\n"
    "    }\n"
    "}\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "// for each tile of the screen, we traverse the list of commands of the regiom and if the command has an impact on the tile\n"
    "// we add the command to the linked list of the tile\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "kernel void tile_bin(constant draw_cmd_arguments& input [[buffer(0)]],\n"
    "                     device tiles_data& output [[buffer(1)]],\n"
    "                     device counters& counter [[buffer(2)]],\n"
    "                     constant const uint16_t* regions_indices [[buffer(3)]],\n"
    "                     ushort3 thread_pos [[thread_position_in_grid]])\n"
    "{\n"
    "    // index.xy = tile index relative to the region\n"
    "    // index.z = region index\n"
    "    ushort region_index = thread_pos.z;\n"
    "    ushort2 region_xy = ushort2(region_index % input.num_region_width,\n"
    "                                region_index / input.num_region_width);\n"
    "    ushort2 tile_xy = region_xy * REGION_SIZE + thread_pos.xy;\n"
    "\n"
    "    if (tile_xy.x >= input.num_tile_width || tile_xy.y >= input.num_tile_height)\n"
    "        return;\n"
    "\n"
    "    ushort tile_index = tile_xy.y * input.num_tile_width + tile_xy.x;\n"
    "\n"
    "    // compute tile bounding box\n"
    "    aabb tile_aabb = {.min = float2(tile_xy), .max = float2(tile_xy.x + 1, tile_xy.y + 1)};\n"
    "    tile_aabb.min *= TILE_SIZE; tile_aabb.max *= TILE_SIZE;\n"
    "\n"
    "    float aabb_margin = 0.f;\n"
    "    sdf_operator group_op = op_overwrite;\n"
    "    constant const uint16_t* indices = &regions_indices[region_index * input.num_commands];\n"
    "\n"
    "    for(uint32_t i=0; i<input.num_commands; ++i)\n"
    "    {\n"
    "        uint32_t cmd_index = simd_broadcast_first(indices[i]);\n"
    "        if (cmd_index == LAST_COMMAND)\n"
    "            break;\n"
    "\n"
    "        quantized_aabb cmd_aabb = input.commands_aabb[cmd_index];\n"
    "        if (any(ushort4(tile_xy, cmd_aabb.max_x, cmd_aabb.max_y) < ushort4(cmd_aabb.min_x, cmd_aabb.min_y, tile_xy)))\n"
    "            continue;\n"
    "\n"
    "        draw_command cmd = input.commands[cmd_index];\n"
    "        clip_rect clip = input.clips[cmd.clip_index];\n"
    "\n"
    "        float2 tile_pos = float2(tile_xy * TILE_SIZE);\n"
    "        if (any(tile_pos>float2(clip.max_x, clip.max_y)) || any((tile_pos + TILE_SIZE)<float2(clip.min_x, clip.min_y)))\n"
    "            continue;\n"
    "\n"
    "        constant float* data = &input.draw_data[cmd.data_index];\n"
    "\n"
    "        bool to_be_added = intersection_tile_command(tile_aabb, cmd, group_op, data, input.aa_width + aabb_margin);\n"
    "\n"
    "        // we traverse in reverse order, so the end comes first\n"
    "        if (cmd.type == begin_group)\n"
    "        {\n"
    "            aabb_margin = 0.f;\n"
    "            group_op = op_overwrite;\n"
    "        }\n"
    "        else if (cmd.type == end_group)\n"
    "        {\n"
    "            aabb_margin = data[0];\n"
    "            group_op = (sdf_operator) cmd.extra;\n"
    "        }\n"
    "\n"
    "        if (to_be_added)\n"
    "        {\n"
    "            // allocate one node\n"
    "            uint new_node_index = atomic_fetch_add_explicit(&counter.num_nodes, 1, memory_order_relaxed);\n"
    "\n"
    "            // avoid access beyond the end of the buffer\n"
    "            if (new_node_index<input.max_nodes)\n"
    "            {\n"
    "                // insert in the linked list the new node\n"
    "                output.nodes[new_node_index] = (tile_node)\n"
    "                {\n"
    "                    .command_index = (uint16_t)cmd_index,\n"
    "                    .next  = output.head[tile_index],\n"
    "                    .command_type = (uint8_t) cmd.type\n"
    "                };\n"
    "\n"
    "                output.head[tile_index] = new_node_index;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    clean_list(output, tile_index);\n"
    "\n"
    "    // if the tile has some draw command to proceed\n"
    "    if (output.head[tile_index] != INVALID_INDEX)\n"
    "    {\n"
    "        uint pos = atomic_fetch_add_explicit(&counter.num_tiles, 1, memory_order_relaxed);\n"
    "\n"
    "        // add tile index\n"
    "        output.tile_indices[pos] = tile_index;\n"
    "    }\n"
    "}\n"
    "\n"
    "\n"
    "// ---------------------------------------------------------------------------------------------------------------------------\n"
    "kernel void write_icb(device counters& counter [[buffer(0)]],\n"
    "                      device output_command_buffer& indirect_draw [[buffer(1)]])\n"
    "{\n"
    "    render_command cmd(indirect_draw.cmd_buffer, 0);\n"
    "    cmd.draw_primitives(primitive_type::triangle_strip, 0, 4, atomic_load_explicit(&counter.num_tiles, memory_order_relaxed), 0);\n"
    "}\n"
    "\n"
;
#endif
